

### 数据类型

1. C是有类型的, 必须先定义or声明, 并且确定类型
2. 之后语言
   1. C++/ java 更强调类型, 检查严格
   2. javascript, python, php 不看类型, 不定义
3. 两派系
   1. 支持强类型: 尽早发现简单错误
   2. 反对强类型: 强迫程序员面对底层, 实现而非事务逻辑
4. 总的来说: 早期语言强调类型, 后期的不强大
5. C语言有类型, 但对类型的安全检查不够

类型

1. 整数: char, short, int, long, long long(1,2,4,8,8 byte)
2. 浮点: float, double, long double(16byte)
3. 逻辑: bool
4. 指针
5. 自定义类型

类型不同: 

1. 输出%d, %ld, %ld

2. 范围 char < short < int < float < double
3. 内存表达形式: 二进制(补码), 编码(浮点形式, 不能直接加法器运算)
4. sizeof 告诉变量or类型的大小, 是静态编译确定的, 不会运行, sizeof(a++)  不会让a++ 

#### 整数类型

1. 不带小数的数, 也是表达内部存储的一种方式

2. char, short, int, long, long long(1,2,4,8,8 byte), 每种类型可以用unsigned修饰 

3. int, long size 取决于编译器, 通常是一个字长(寄存器宽度8byte=64bit)

4. 整数的内部表达: 用补码表达, 使用最高位成为符号位, 每一种类型都有数据范围, char的范围是-128 到127

5. 使用unsigned, 不用补码方式去解析数, 用纯二进制数去解析11111111=255. 使用255U让这个数成为unsigned, unsigned目的不是为了扩大范围, 为了做纯二进制运算, 用来移位

6. 整数运算可能越界

7. 虽然整数有5种, 但是输出只有两种 %d(int), %ld(long long), %u(unsigned long long)

8. ```c
   char c = -1;
   int i = -1;
   printf("c=%u, i =%u\n", c);	// 都输出4284867295 
   // 当把小于int的变量传递给printf, 编译器会全部转换成int(符号扩展)
   // 当把大于int的变量传递给printf, 会转换成long long
   // 会先把char转换成unsigned int(符号扩展)成全1, 再输出
   ```

9. 输出, scanf 8进制 %o, 16进制 %x, 这只是如何把数字表达成字符串, 入内部如何表达数字无关

10. 不管计算机内部如何存储数据, 重点是用什么方式去看待它, 解析这个数!

11. 选择整数类型: C语言有太多类型, 早期为了表达硬件的细节. 

    1. 没特别需要就用int, 一次内存读写就是int(32bit), 一次计算也是int
    2. 现代编译器也会内存对齐
    3. unsigned只是输出不同, 内部计算是一样的



#### 浮点类型

1. 整数用二进制存储, 而浮点有IEEE编码方式, 有fpu专用硬件支持

   1. float 32位,  10^-38 到 10^38, 0周围有不准的, 有效数字7位
   2. double 64位, 10^-308 到 10^308, 有效数字15位

2. 输入输出

   |        | scanf | printf                 |
   | ------ | ----- | ---------------------- |
   | float  | %f    | %f, %e(输出科学计数法) |
   | double | %lf   | %f, %e                 |

   %.16f 可以表示输出小数点后16位

3.  数学中的浮点数是连续的, 任何两个小数中间有无穷个数. 但是计算机只能表达有限个浮点数, 对无法表达的数, 会找一个最近的数来表达

4. 正数 / 0.0 为 inf, 负数 / 0.0 = -inf

5. 浮点数运算是没有精度的, 0.1 + 0.2 != 0.3 内部存的数据不是严格的0.1

   1. f1 == f2   error
   2. fabs(f1 - f2) < 1e-12 才行

6. float a = 0.123f  带小数点的字面量默认是double, 用f来表明float

7. 如果没有特殊要求, 只用double, 不用float!



#### 逻辑类型

1. c没有bool类型, #include <stdbool.h> 可以用bool, 实际上还是用int存
2. 逻辑运算, !, &&, || , 优先级依次减小
3. 短路:左边成功了, 右边就不做了. 不要把赋值放在条件表达式中!



#### 自动类型转换

1. 运算符两边类型不同, 会自动转换成较大的类型
2. 对于printf, 任何小于int都会转换成int, float会变成double
3. scanf 不会, 要明确知道对应类型, 输入short使用%hd
4. 强制类型转换, 一般变小的类型, (类型)值, 这时候有安全性问题
   1. 只会计算一个新类型的值, 不会改变变量的值or类型
5. 条件运算符: c = a > b ? 1 : 2; 不希望使用!
6. 逗号运算符: 连接两个表达式, 用右边的值作为结果. 优先级最低



### 指针



应用场景: 

1. 交换两个变量的值
2. 函数返回多个值 
3. 函数返回运算的状态-1 or 0, 真正结果通过指针参数来返回
   1. 对C++和java可以通过异常处理函数来处理异常

常见错误: 指针没有初始化



传入函数的数组变成了  指向数组的指针!

在定义数组时候sizeof(a) 可以返回数组大小

在函数使用时候sizeof(a) 变成指针大小 = 4! 但是仍然可以用a[2] 去使用

数组变量是特殊的指针!

1. 数组变量本身 表达数组, int a[10]; int *p = a;

2. 数组的单元表达是变量, 用&取地址符才行, int *p2 = &a[2];

3. [] 可以对数组做, 也可以对指针做

4. ```c
   int min = 2;
   int *p = &min;
   printf("%d %d \n", *p, p[0]);	// 指针用p[0] 也可以访问变量值
   ```

5. 数组变量是const 指针, 初始化后, 不能被赋值

6. ```c
   int a[] = {1,2,3,4};
   int b[] =a;	// error, b[] 等价于 int * const b;
   int *q = a;	// 可以
   ```



指针与const:

1. 指针是const, 指针被绑定到对象上, 不能指向另一个值了!

2. ```c
   int *const q = &i;
   *q = 32;	// ok
   q++;	// error
   ```

3. 指针对象是const: 不能通过指针去修改那个变量了(变量本身和指针本身可以变化)

4. ```c
   const int * p = &i;
   *p = 26;	// error
   i = 26;		// ok
   p++;		// ok
   ```

5. ```c
   void f(const int* x);	// 保证不会通过指针去修改x, 例如传递结构进去
   void f(const int a[]);	// 不希望数组被修改 
   ```

6. const int a[]: a[] 本身是const指针, a不能指向别的值了; 此外a内部的变量也是const不能修改. 必须通过初始化的方式去赋值

#### 指针运算

1. 对char 指针加1, 地址加1. 对int指针加1, 地址加4! sizeof(int) = 4. 其实是相当与数组下标加1, 类似与int数组获取下一个数
2. 可以用printf("%p") %p 来输出16进制地址
3. 指针有不同类型, 注意不能混合
4. void * 表示还不清楚指向什么, 计算时候和char * 相同

#### 动态内存分配

1. int \*a = (int\*) malloc(num \*  sizeof(int));  最后需要free()!
2. 只能还分配的起始地址
3. 常见问题: 申请了没free, 会